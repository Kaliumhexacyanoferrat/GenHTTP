using GenHTTP.Api.Protocol;

namespace GenHTTP.Modules.Reflection;

/// <summary>
/// A result of a service invocation that wraps a given payload and
/// still allows to modify the response generated by the server.
/// </summary>
/// <typeparam name="T">The type of payload wrapped by this result</typeparam>
/// <remarks>
/// Useful to change response properties (such as the status code or headers)
/// while still keeping the content in place. Note that returning a result
/// will not change the serialized outcome of the service method, it will be
/// the same as it would be when you would just return the payload itself.
/// </remarks>
public class Result<T> : IResultWrapper, IResponseModification<Result<T>>
{
    private Connection? _connectionHandling;

    private FlexibleContentType? _contentType;

    private List<Cookie>? _cookies;

    private string? _encoding;

    private DateTime? _expires;

    private Dictionary<string, string>? _headers;

    private DateTime? _modified;
    private FlexibleResponseStatus? _status;

    #region Initialization

    /// <summary>
    /// Creates a new result with the given payload.
    /// </summary>
    /// <param name="payload">The payload to be returned to the client</param>
    public Result(T? payload)
    {
        Payload = payload;
    }

    #endregion

    #region Get-/Setters

    /// <summary>
    /// The actual data to be returned to the client.
    /// </summary>
    public T? Payload { get; }

    object? IResultWrapper.Payload => Payload;

    #endregion

    #region Functionality

    /// <inheritdoc />
    public Result<T> Status(ResponseStatus status)
    {
        _status = new FlexibleResponseStatus(status);
        return this;
    }

    /// <inheritdoc />
    public Result<T> Status(int status, string reason)
    {
        _status = new FlexibleResponseStatus(status, reason);
        return this;
    }

    /// <inheritdoc />
    public Result<T> Connection(Connection handling)
    {
        _connectionHandling = handling;
        return this;
    }

    /// <inheritdoc />
    public Result<T> Header(string key, string value)
    {
        _headers ??= new Dictionary<string, string>();

        _headers[key] = value;

        return this;
    }

    /// <inheritdoc />
    public Result<T> Expires(DateTime expiryDate)
    {
        _expires = expiryDate;
        return this;
    }

    /// <inheritdoc />
    public Result<T> Modified(DateTime modificationDate)
    {
        _modified = modificationDate;
        return this;
    }

    /// <inheritdoc />
    public Result<T> Cookie(Cookie cookie)
    {
        (_cookies ??= []).Add(cookie);

        return this;
    }

    /// <inheritdoc />
    public Result<T> Type(FlexibleContentType contentType)
    {
        _contentType = contentType;
        return this;
    }

    /// <inheritdoc />
    public Result<T> Encoding(string encoding)
    {
        _encoding = encoding;
        return this;
    }

    public void Apply(IResponseBuilder builder)
    {
        if (_status != null)
        {
            var value = _status.Value;

            builder.Status(value.RawStatus, value.Phrase);
        }

        if (_connectionHandling != null)
        {
            builder.Connection(_connectionHandling.Value);
        }

        if (_headers != null)
        {
            foreach (var kv in _headers)
            {
                builder.Header(kv.Key, kv.Value);
            }
        }

        if (_expires != null)
        {
            builder.Expires(_expires.Value);
        }

        if (_modified != null)
        {
            builder.Modified(_modified.Value);
        }

        if (_cookies != null)
        {
            foreach (var cookie in _cookies)
            {
                builder.Cookie(cookie);
            }
        }

        if (_contentType is not null)
        {
            builder.Type(_contentType);
        }

        if (_encoding != null)
        {
            builder.Encoding(_encoding);
        }
    }

    #endregion

}
